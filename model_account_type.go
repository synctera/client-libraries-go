/*
Synctera API

<h2>Let's build something great.</h2><p>Welcome to the official reference documentation for Synctera APIs. Our APIs are the best way to automate your company's banking needs and are designed to be easy to understand and implement.</p><p>We're continuously growing this library and what you see here is just the start, but if you need something specific or have a question, <a class='text-blue-600' href='https://synctera.com/contact' target='_blank' rel='noreferrer'>contact us</a>.</p>

API version: 0.5.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package synctera

import (
	"encoding/json"
	"fmt"
)

// AccountType the model 'AccountType'
type AccountType string

// List of account_type
const (
	ACCOUNTTYPE_SAVING         AccountType = "SAVING"
	ACCOUNTTYPE_CHECKING       AccountType = "CHECKING"
	ACCOUNTTYPE_LINE_OF_CREDIT AccountType = "LINE_OF_CREDIT"
	ACCOUNTTYPE_ODP            AccountType = "ODP"
)

var allowedAccountTypeEnumValues = []AccountType{
	"SAVING",
	"CHECKING",
	"LINE_OF_CREDIT",
	"ODP",
}

func (v *AccountType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := AccountType(value)
	for _, existing := range allowedAccountTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid AccountType", value)
}

// NewAccountTypeFromValue returns a pointer to a valid AccountType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewAccountTypeFromValue(v string) (*AccountType, error) {
	ev := AccountType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for AccountType: valid values are %v", v, allowedAccountTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v AccountType) IsValid() bool {
	for _, existing := range allowedAccountTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to account_type value
func (v AccountType) Ptr() *AccountType {
	return &v
}

type NullableAccountType struct {
	value *AccountType
	isSet bool
}

func (v NullableAccountType) Get() *AccountType {
	return v.value
}

func (v *NullableAccountType) Set(val *AccountType) {
	v.value = val
	v.isSet = true
}

func (v NullableAccountType) IsSet() bool {
	return v.isSet
}

func (v *NullableAccountType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAccountType(val *AccountType) *NullableAccountType {
	return &NullableAccountType{value: val, isSet: true}
}

func (v NullableAccountType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAccountType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
